const hermes = require('@postman/hermes');

const LinuxAutoUpdater = require('./LinuxAutoUpdater');

describe('LinuxAutoUpdater', function () {
  let linuxAutoUpdater;
  const options = {
    quitApp: jest.fn(),
    logger: {
      error: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
    },
    appInstallationPath: '/home/postman/Downloads/postman-app',
    appName: 'postman',
    originalFs: require('fs'),
  };

  describe('downloadUpdate', function () {
    beforeEach(function () {
      linuxAutoUpdater = new LinuxAutoUpdater(options);
    });

    it('should throw an error if the updateInfo.appName is empty', () => {
      let err = null,
        appName = '',
        downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
        downloadDirectory = '/home/postman/Downloads/postman-app/';

      try {
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      } catch (e) {
        err = e;
      } finally {
        expect(err).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if the updateInfo.appName is not of type string', () => {
      let err = null,
        appName = 1,
        downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
        downloadDirectory = '/home/postman/Downloads/postman-app/';

      try {
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      } catch (e) {
        err = e;
      } finally {
        expect(err).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if the updateInfo.downloadURL is empty', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL = '';
        const downloadDirectory = '/home/postman/Downloads/postman-app/';
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });

    it('should throw an error if the updateInfo.downloadURL is not of type string', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL = 8675;
        const downloadDirectory = '/home/postman/Downloads/postman-app/';
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });

    it('should throw an error if the updateInfo.downloadDirectory is empty', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64';
        const downloadDirectory = '';
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });

    it('should throw an error if the updateInfo.downloadDirectory is not of type string', async () => {
      const promise = new Promise((resolve, reject) => {
        const appName = 'Postman';
        const downloadURL =
          'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64';
        const downloadDirectory = 1;
        const errorHandling = function (err) {
          try {
            expect(err).toBeInstanceOf(Error);
            resolve();
          } catch (e) {
            reject(e);
          }
        };

        linuxAutoUpdater.on('error', errorHandling);
        linuxAutoUpdater.downloadUpdate(
          appName,
          downloadURL,
          downloadDirectory
        );
      });

      await promise;
    });
  });

  describe('cleanUp', function () {
    let loggerSpy, hermesClearSpy;

    beforeEach(function () {
      linuxAutoUpdater = new LinuxAutoUpdater(options);
      loggerSpy = jest.spyOn(options.logger, 'info');
      hermesClearSpy = jest.spyOn(hermes, 'clear');
    });

    afterEach(function () {
      loggerSpy.mockRestore();
      hermesClearSpy.mockRestore();
    });

    it('should throw an error if options(argument) is empty', async () => {
      let options = {},
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options have falsy values', async () => {
      let options = false,
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appInstallationPath is empty', async () => {
      let options = {
          appName: 'Postman',
          appInstallationPath: '',
        },
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appInstallationPath is not a string', async () => {
      let options = {
          appName: 'Postman',
          appInstallationPath: 123,
        },
        expectedError =
          'InvalidArgumentException: Hermes~clear - clearInputData.directory should be of type string', // eslint-disable-line max-len
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(hermesClearSpy).toHaveBeenCalledTimes(1);
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appName is empty', async () => {
      let options = {
          appName: '',
          appInstallationPath: '/home/postman/Downloads/postman-app/',
        },
        expectedError =
          'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out',
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err.message).toEqual(expectedError);
              expect(loggerSpy).toHaveBeenCalledWith(expectedError, options);
              expect(hermesClearSpy).not.toHaveBeenCalled();
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });

    it('should throw an error if options.appName is not a string', async () => {
      let options = {
          appName: 123,
          appInstallationPath: '/home/postman/Downloads/postman-app/',
        },
        promise = new Promise((resolve, reject) => {
          linuxAutoUpdater.cleanUp(options, (err) => {
            try {
              expect(err).toBeInstanceOf(Error);
              expect(hermesClearSpy).toHaveBeenCalledTimes(1);
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });

      await promise;
    });
  });

  describe('quitAndInstall', function () {
    let quitAppSpy, hermesSwapSpy;

    beforeEach(function () {
      linuxAutoUpdater = new LinuxAutoUpdater(options);
      quitAppSpy = jest.spyOn(options, 'quitApp');
      hermesSwapSpy = jest.spyOn(hermes, 'swap');
    });

    afterEach(function () {
      quitAppSpy.mockRestore();
      hermesSwapSpy.mockRestore();
    });

    it('should throw an error if updateInfo is empty', () => {
      let err = null,
        updateInfo = {};

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo is not an object', () => {
      let err = null,
        updateInfo = 'foo';

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo.eId is empty', () => {
      let err = null,
        updateInfo = {
          eID: '',
          packageName: 'somePackage',
          downloadURL: 'http://sample.com/foo.tar.gz',
          downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
          downloadChecksumAlgorithm: 'sha1',
          downloadInfo: {
            status: 'DOWNLOAD_COMPLETED',
            error: null,
            downloadDirectory: 'User/PathForDownloadDirectory',
          },
          extractInfo: {
            status: 'EXTRACTION_SUCCESSFUL',
            error: null,
            extractDirectory: 'User/PathForExtractDirectory',
          },
        };

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo.packageName is empty', () => {
      let err = null,
        updateInfo = {
          eID: 'somePackage-xxxxxxxxxxxxx',
          packageName: '',
          downloadURL: 'http://sample.com/foo.tar.gz',
          downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
          downloadChecksumAlgorithm: 'sha1',
          downloadInfo: {
            status: 'DOWNLOAD_COMPLETED',
            error: null,
            downloadDirectory: 'User/PathForDownloadDirectory',
          },
          extractInfo: {
            status: 'EXTRACTION_SUCCESSFUL',
            error: null,
            extractDirectory: 'User/PathForExtractDirectory',
          },
        };

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });

    it('should throw an error if updateInfo.extractInfo is empty', () => {
      let err = null,
        updateInfo = {
          eID: 'somePackage-xxxxxxxxxxxxx',
          packageName: 'somePackage',
          downloadURL: 'http://sample.com/foo.tar.gz',
          downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
          downloadChecksumAlgorithm: 'sha1',
          downloadInfo: {
            status: 'DOWNLOAD_COMPLETED',
            error: null,
            downloadDirectory: 'User/PathForDownloadDirectory',
          },
          extractInfo: {},
        };

      try {
        linuxAutoUpdater.quitAndInstall(updateInfo);
      } catch (e) {
        err = e;
      } finally {
        expect(hermesSwapSpy).toHaveBeenCalledTimes(1);
        expect(quitAppSpy).not.toHaveBeenCalled();
        expect(err.message).toBeTruthy();
      }
    });
  });
});
